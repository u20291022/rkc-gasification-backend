# API Методы - Подробная логика работы

## Содержание
1. [Аутентификация](#аутентификация)
2. [Управление адресами](#управление-адресами)
3. [Работа с данными газификации](#работа-с-данными-газификации)
4. [Получение справочников](#получение-справочников)
5. [Экспорт данных](#экспорт-данных)
6. [Служебные функции](#служебные-функции)

---

## Аутентификация

### `POST /v1/auth/login`
**Файл**: `app/api/v1/endpoints/gazification/auth.py`

#### Логика работы:
1. **Получение данных**: Принимает email и password пользователя
2. **Поиск пользователя**: Ищет пользователя в таблице `s_gazifikacia.users` по email
3. **Проверка пароля**: 
   - Создает MD5 хеш введенного пароля
   - Сравнивает с сохраненным хешем в БД
4. **Результат**: Возвращает `{"authenticated": true/false}`

#### Особенности:
- Использует MD5 хеширование для паролей
- Не создает сессии или токены (простая проверка логин/пароль)
- При неуспешной аутентификации возвращает `authenticated: false` без детализации причины

---

## Управление адресами

### `GET /v1/mo`
**Файл**: `app/api/v1/endpoints/gazification/municipality.py`

#### Логика работы:
1. **Получение данных**: Запрос к таблице `sp_s_subekty.v_all_name_mo` для получения муниципалитетов
2. **Фильтрация**: Показывает только муниципалитеты, которые есть в данных газификации
3. **Сортировка**: Результат сортируется по названию муниципалитета
4. **Статистика**: Для каждого муниципалитета подсчитывает количество адресов с данными газификации

#### Структура ответа:
```json
{
  "data": {
    "municipalities": [
      {
        "id": 1,
        "name": "Название МО",
        "addresses_count": 150
      }
    ]
  }
}
```

---

### `GET /v1/mo/{mo_id}/district`
**Файл**: `app/api/v1/endpoints/gazification/district.py`

#### Логика работы:
1. **Фильтрация по МО**: Ищет все адреса для указанного муниципалитета
2. **Объединение полей**: Использует `COALESCE(district, city)` для получения района/города
3. **Уникальность**: Группирует результаты, исключая дубликаты
4. **Статистика газификации**: Для каждого района показывает:
   - Общее количество адресов
   - Количество газифицированных адресов (type_address = 3)
   - Количество не газифицированных адресов (type_address = 4)

#### Особенности:
- Если поле `district` пустое, использует поле `city`
- Исключает записи где и `district` и `city` равны NULL
- Сортировка по названию района

---

### `GET /v1/mo/{mo_id}/district/{district}/street`
**Файл**: `app/api/v1/endpoints/gazification/street.py`

#### Логика работы:
1. **Многоуровневая фильтрация**: Фильтрует по МО и району/городу
2. **Гибкий поиск района**: Ищет по полю `district` ИЛИ `city`
3. **Группировка улиц**: Группирует уникальные названия улиц
4. **Подсчет статистики**: Для каждой улицы считает количество адресов и статус газификации

#### Логика поиска района:
```sql
WHERE (district = 'район' OR city = 'район')
```

---

### `GET /v1/mo/{mo_id}/district/{district}/street/{street}/house`
**Файл**: `app/api/v1/endpoints/gazification/house.py`

#### Логика работы:
1. **Поиск домов**: Фильтрует адреса по МО, району и улице
2. **Группировка**: Группирует по номеру дома, исключая дубликаты
3. **Статус газификации**: Показывает статус газификации для каждого дома
4. **Сортировка**: Естественная сортировка домов (1, 2, 10, а не 1, 10, 2)

#### Особенности:
- Исключает записи без номера дома (`house IS NOT NULL`)
- Показывает только уникальные номера домов

---

### `GET /v1/mo/{mo_id}/district/{district}/street/{street}/house/{house}/flat`
**Файл**: `app/api/v1/endpoints/gazification/flat.py`

#### Логика работы:
1. **Поиск квартир**: Фильтрует по всем предыдущим параметрам + номер дома
2. **Обработка квартир**: Показывает все квартиры в указанном доме
3. **Статус каждой квартиры**: Для каждой квартиры показывает индивидуальный статус газификации

#### Особенности:
- Может возвращать записи с `flat = NULL` (частные дома)
- Сортировка по номеру квартиры

---

### `POST /v1/add`
**Файл**: `app/api/v1/endpoints/gazification/add_address.py`

#### Логика работы:
1. **Проверка существования**: Проверяет, существует ли уже такой адрес
2. **Создание адреса**: Если адрес не существует, создает новую запись в `t_address_v2`
3. **Запись газификации**: Создает запись в `t_gazifikacia_data` со статусом газификации
4. **Транзакция**: Все операции выполняются в одной транзакции
5. **Логирование**: Записывает операцию в лог
6. **Активность**: Обновляет счетчик активности пользователя

#### Параметры статуса газификации:
- `has_gas = 'true'` → `id_type_address = 3` (подключен к газу)
- `has_gas = 'false'` → `id_type_address = 4` (не подключен к газу)  
- `has_gas = 'not_exist'` → `id_type_address = 6` (адреса не существует)

#### Структура запроса:
```json
{
  "mo_id": 1,
  "district": "Центральный",
  "street": "Ленина",
  "house": "1",
  "flat": "10",
  "has_gas": "true",
  "from_login": "user@example.com",
  "session_id": "abc123"
}
```

---

## Работа с данными газификации

### `POST /v1/upload`
**Файл**: `app/api/v1/endpoints/gazification/upload.py`

#### Логика работы:
1. **Валидация полей**: Проверяет существование всех `id` полей в таблице `t_type_value`
2. **Поиск/создание адреса**: 
   - Ищет существующий адрес по всем параметрам
   - Если не найден, создает новый адрес
3. **Сохранение ответов**: Для каждого поля создает запись в `t_gazifikacia_data`
4. **Транзакция**: Все операции в одной транзакции
5. **Активность**: Записывает активность пользователя

#### Логика поиска адреса:
```python
# Точное совпадение всех полей, включая NULL значения
address_query = AddressV2.filter(
    id_mo=request.address.mo_id,
    street=request.address.street,
    house=request.address.house
)

# Обработка района (может быть NULL)
if request.address.district:
    address_query = address_query.filter(district=request.address.district)
else:
    address_query = address_query.filter(district__isnull=True)

# Обработка квартиры (может быть NULL)
if request.address.flat:
    address_query = address_query.filter(flat=request.address.flat)
else:
    address_query = address_query.filter(flat__isnull=True)
```

#### Структура запроса:
```json
{
  "address": {
    "mo_id": 1,
    "district": "Центральный",
    "street": "Ленина", 
    "house": "1",
    "flat": "10"
  },
  "fields": [
    {
      "id": 12,
      "value": "Планирует, но не в этом году"
    }
  ],
  "from_login": "user@example.com",
  "session_id": "abc123"
}
```

#### Особенности:
- Все записи помечаются как `is_mobile = True`
- Каждое поле сохраняется отдельной записью
- `id_type_address = 4` (не подключены к газу) для всех полей формы

---

### `POST /v1/update-gas-status`
**Файл**: `app/api/v1/endpoints/gazification/update_gas_status.py`

#### Логика работы:
1. **Поиск адреса**: Ищет адрес по тем же критериям, что и в `upload.py`
2. **Проверка существования**: Если адрес не найден, возвращает ошибку 404
3. **Обновление/создание данных газификации**:
   - Ищет существующие записи о газификации для найденного адреса
   - Если есть - обновляет `id_type_address` и `from_login`
   - Если нет - создает новую запись
4. **Множественные адреса**: Обрабатывает все найденные адреса (может быть несколько)
5. **Активность**: Записывает активность пользователя

#### Логика определения статуса:
```python
id_type_address = 4  # По умолчанию - не подключены
if request.has_gas == 'true':
    id_type_address = 3  # Подключены к газу
elif request.has_gas == 'not_exist':
    id_type_address = 6  # Адреса не существует
```

#### Проблемы в текущей реализации:
⚠️ **Выявленные проблемы**:
- Каждый адрес обрабатывается в отдельной транзакции
- Логирование происходит для каждого адреса отдельно
- Обновляются все записи газификации для адреса (может быть избыточно)

---

## Получение справочников

### `GET /v1/type-values`
**Файл**: `app/api/v1/endpoints/gazification/type_values.py`

#### Логика работы:
1. **Получение типов значений**: Загружает все записи из `t_type_value` где `for_mobile = true`
2. **Загрузка типов полей**: Получает справочник типов полей из `field_type`
3. **Обработка связей**: Загружает и обрабатывает связи между полями из `field_reference`
4. **Получение вариантов ответов**: Для каждого поля загружает варианты ответов из `field_answers`
5. **Сортировка**: Сортирует по полю `order`

#### Логика обработки связей:
```python
# Нормализация значений для сравнения
normalized_value = str(ref.field_origin_value).lower().strip('"\'')

# Обработка булевых значений
if field_value.lower() in ("true", "false"):
    original_value = field_value.lower()
```

#### Структура ответа:
```json
{
  "data": {
    "type_values": [
      {
        "id": 12,
        "order": 11,
        "type_value": "Причина по которой не желает подключиться к газу",
        "description": "",
        "field_type": "select",
        "related_fields": [
          {
            "value": "иное",
            "related_field_id": 9
          }
        ],
        "answers": [
          "Ожидает финансирования в рамках программы",
          "Недостаточно денежных средств для установки оборудования"
        ],
        "answers_size": ["full", "full"]
      }
    ]
  }
}
```

#### Особенности:
- Варианты ответов сортируются по полю `order` (новая функциональность)
- Поддерживает условные связи между полями
- Исключает поля типа "info" из результата

---

## Экспорт данных

### `GET /v1/export`
**Файл**: `app/api/v1/endpoints/gazification/export_excel.py`

#### Логика работы:
1. **Получение данных**: Вызывает `get_gazification_data()` с фильтрами
2. **Дедупликация адресов**: Удаляет дубликаты, оставляя самые свежие записи
3. **Подготовка данных**: 
   - Форматирует даты с добавлением +7 часов к UTC
   - Преобразует статус газификации в читаемый вид
   - Добавляет столбцы для всех вопросов
4. **Создание Excel**: Использует `pandas` и `xlsxwriter` для создания файла
5. **Стилизация**: Применяет форматирование (границы, цвета, автоширина столбцов)
6. **Возврат файла**: Возвращает временный файл для скачивания

#### Логика дедупликации:
```python
# Создание ключа для уникальности адреса
address_key = (
    address.get('id_mo'),
    (address.get('district') or '').strip().lower(),
    (address.get('city') or '').strip().lower(), 
    (address.get('street') or '').strip().lower(),
    (address.get('house') or '').strip().lower(),
    (address.get('flat') or '').strip().lower()
)

# Оставляем запись с более новой датой
if current_date and (not existing_date or current_date > existing_date):
    unique_addresses[address_key] = address
```

#### Столбцы в Excel:
- Дата создания
- Создатель адреса  
- Отправитель
- Муниципалитет
- Район
- Улица
- Дом
- Квартира
- Газифицирован?
- [Динамические столбцы для каждого вопроса]

---

### `GET /v1/export-activity`
**Файл**: `app/api/v1/endpoints/gazification/export_activity.py`

#### Логика работы:
1. **Получение данных активности**: Вызывает `get_activity_data()` из `export_utils.py`
2. **Форматирование дат**: Добавляет +7 часов и форматирует в `DD.MM.YYYY HH:MM`
3. **Подготовка данных**: Создает DataFrame с тремя столбцами:
   - Дата входа (date_create из сессии)
   - Аккаунт (email пользователя)
   - Количество внесений (activity_count)
4. **Создание Excel**: Аналогично основному экспорту, но проще
5. **Стилизация**: Применяет форматирование для читаемости

#### Логика получения данных активности:
```python
# Фильтрация по датам (опционально)
if date_from:
    query = query.filter(date_create__gte=date_from)
if date_to:
    query = query.filter(date_create__lte=date_to)

# Получение данных с сортировкой по дате
activities = await query.order_by('-date_create').values(
    'email', 'activity_count', 'date_create'
)
```

---

## Служебные функции

### Функция `record_activity()`
**Файл**: `app/core/utils.py`

#### Логика работы:
1. **Проверка session_id**: Если session_id не передан, функция ничего не делает
2. **Поиск существующей сессии**: Ищет запись в таблице `activity` по session_id
3. **Обновление/создание**:
   - Если сессия существует: увеличивает `activity_count` на 1
   - Если сессии нет: создает новую запись с `activity_count = 1`
4. **Сохранение**: Использует `save()` или `create()` в зависимости от случая

```python
async def record_activity(email: str, session_id: str):
    """Записывает или обновляет активность пользователя"""
    if not session_id:
        return
        
    activity = await Activity.filter(session_id=session_id).first()
    
    if activity:
        activity.activity_count += 1
        await activity.save(update_fields=['activity_count'])
    else:
        await Activity.create(
            session_id=session_id,
            email=email,
            activity_count=1
        )
```

#### Использование:
- Вызывается в `add_address`, `upload`, `update_gas_status`
- Позволяет отслеживать активность пользователей по сессиям
- Данные используются для экспорта активности

---

### Функция `get_gazification_data()`
**Файл**: `app/core/export_utils.py`

#### Логика работы:
1. **Получение статусов газификации**: 
   - Фильтрует `GazificationData` по `id_type_address IN (3,4)` и `is_mobile = True`
   - Группирует по адресам, оставляя самые свежие записи
2. **Фильтрация адресов**: 
   - Ищет адреса из списка с данными газификации
   - Применяет фильтры по МО, району, улице, датам
3. **Получение названий МО**: Загружает названия муниципалитетов
4. **Получение вопросов**: Загружает вопросы для мобильного приложения (исключая тип "info")
5. **Получение ответов**: Загружает все ответы пользователей на вопросы

#### Особенности фильтрации:
```python
# Гибкий поиск по району
if district:
    normalized_district = district.strip().lower()
    query = query.annotate(
        district_lower=Lower("district"),
        city_lower=Lower("city")
    ).filter(
        (Q(district_lower=normalized_district)) | 
        (Q(district__isnull=True) & Q(city_lower=normalized_district))
    )
```

#### Возвращаемые данные:
- `addresses`: список адресов с информацией о газификации
- `questions`: список вопросов опросника  
- `answers`: словарь ответов по адресам `{address_id: {question_id: answer}}`

---

## Обработка ошибок

### Стандартные исключения:
- `DatabaseError`: Ошибки при работе с БД
- `NotFoundError`: Когда данные не найдены
- `ValidationError`: Ошибки валидации входных данных

### Middleware логирования:
- Логирует все запросы и ответы
- Добавляет уникальный `request_id` к каждому запросу
- Измеряет время выполнения запросов
- Логирует ошибки с полным контекстом

### Структура ответов:
```json
// Успешный ответ
{
  "ok": true,
  "message": "Успех",
  "data": { /* данные */ }
}

// Ответ с ошибкой  
{
  "ok": false,
  "message": "Описание ошибки",
  "data": null
}
```

---

## Безопасность и производительность

### Транзакции:
- Критические операции выполняются в транзакциях
- Гарантируется целостность данных при создании связанных записей

### Логирование:
- Все операции с БД логируются через `log_db_operation()`
- Ведется подробный лог запросов и ошибок
- Отслеживается производительность

### Валидация:
- Проверка существования внешних ключей перед созданием записей
- Валидация входных данных через Pydantic схемы
- Обработка NULL значений в фильтрах

### Оптимизация:
- Использование `prefetch_related()` для загрузки связанных данных
- Группировка данных для минимизации запросов к БД
- Дедупликация данных перед обработкой

---

## Мониторинг активности

### Система активности:
1. **Сессии**: Каждый пользователь работает в рамках сессии (session_id)
2. **Счетчики**: Для каждой сессии ведется счетчик операций
3. **Отчетность**: Данные активности доступны через экспорт
4. **Анализ**: Позволяет отслеживать продуктивность пользователей

### Принцип работы:
- При каждом внесении данных (`add`, `upload`, `update-gas-status`) увеличивается счетчик
- Один session_id = одна рабочая сессия пользователя
- В экспорте показывается: когда пользователь зашел (date_create) и сколько операций выполнил

Эта система позволяет анализировать эффективность работы операторов и планировать нагрузку.
